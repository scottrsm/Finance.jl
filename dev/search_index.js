var documenterSearchIndex = {"docs":
[{"location":"#Finance.jl-Documentation","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"","category":"section"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"CurrentModule = Finance","category":"page"},{"location":"#Overview","page":"Finance.jl Documentation","title":"Overview","text":"","category":"section"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"Below is a collection of functions which are useful to find signals  in time series data.","category":"page"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"sigcumsum: This function looks for imbalance in tics.\nisConvertible: This function determines if one type can be converted to another.\ntic_diff1: As tics are irregular, this function provides a                way to compute the numerical derivative                with respect to an irregular time series.\ntic_diff2: This function finds the numerical second derivative               with respect to irregular time series data.\nema:       Computes the Exponential Moving Average of a time series. \nema_std:   Computes the standard deviation of an              Exponential Moving Average of a time series. \nema_stat:  Computes the Exponential Moving Average along with              the associated moving standard deviation, relative skewness,               relative kurtosis.\newt_mean   Computes a exponentially decayed temporal weighted moving average.\npow_n:     Computes the power of a value to a positive integer power               using repeated squaring.","category":"page"},{"location":"#Signals","page":"Finance.jl Documentation","title":"Signals","text":"","category":"section"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"sig_cumsum","category":"page"},{"location":"#Finance.sig_cumsum","page":"Finance.jl Documentation","title":"Finance.sig_cumsum","text":"sig_cumsum(t, x, w, h; chk_inp=false)\n\nReturn a tuple of two vectors: tics, signals.\n\nThe signals are the collections of all deviations from  a running mean (with window length w) of the series.  The threshold of the deviation is h.\n\nDeviation is determined by:\n\nS_t^+ = rm max(0 S_t-1 + x_t - Ex_t-1 S^+_0 = 0\nS_t^- = rm min(0 S_t-1 + x_t - Ex_t-1 S^-_0 = 0\nS_t^hphantom+ = rm max(S^+_t -S^-_t)\n\nCollect all t S_t where h ge S_t.\n\nType Constraints\n\nS <: Real\nT <: Real\n\nArguments\n\nt :: AbstractVector{S} – The tic series to examine.\nx :: AbstractVector{T} – The series to examine.\nw :: Int             – The width of the moving average.\nh :: T                 – The threshold for the deviation to register.\n\nKeyword Arguments\n\nchk_inp=false :: Bool  – Check the input contract?\n\nInput Contract\n\nThe inputs are assumed to satisfy the constraints below.\n\nConstraint Description\n|x| ge 2 The length of x is at least 2.\n|x| = |t| The length of x is equal to the length of t.\nw > 1 The window length is greater than 1.\nh > 0 The deviation threshold is greater than 0.\nforall i t_i+1  t_i The times are increasing; consequently, we have a 1-1 map from t to x.\n\nOutput Components\n\ntd :: AbstractVector{S} – Values of t where deviations occurred.\nxd :: AbstractVector{T} – Values of x where deviations occurred.\n\nOutput Contract\n\n|td| = |xd|\n\nReturn\n\n(td, xd) :: Tuple{AbstractVector{S}, AbstractVector{T}}\n\n\n\n\n\n","category":"function"},{"location":"#Moving-Averages","page":"Finance.jl Documentation","title":"Moving Averages","text":"","category":"section"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"ema","category":"page"},{"location":"#Finance.ema","page":"Finance.jl Documentation","title":"Finance.ema","text":"ema(x,m; h=div(m,2))\n\nCompute the Exponential Moving Average of the sequence x.\n\nType Constraints\n\nT <: Real\n\nArguments\n\nx :: AbstractVector{T} – The series to work with.\nm :: Int             – The width of the decay window.\n\nKeyword Arguments\n\nh=div(m,2) :: Int       – The exponential decay half-life. \n\nInput Contract\n\nThe inputs are assumed to satisfy the constraints below.\n\nConstraint Description\nm > 1 Averaging window length is greater than 1.\nh > 1 Exponential half-life is greater than 1.\n\nOutput\n\nema :: AbstractVector{T} – The exponential moving average of x.\n\nOutput Contract\n\n|x| = |ema|\n\nReturn\n\nema::AbstractVector{T}\n\n\n\n\n\n","category":"function"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"ema_std","category":"page"},{"location":"#Finance.ema_std","page":"Finance.jl Documentation","title":"Finance.ema_std","text":"ema_std(x, m; h=div(m,2), init_sig=nothing)\n\nCompute the Moving Exponential Standard Deviation of the sequence x. By default, the initial std is taken to be the standard deviation of  the first window (of length m). However, a user specified value may be used instead.\n\nType Constraints\n\nT <: Real\n\nArguments\n\nx :: AbstractVector{T} – The series to work with.\nm :: Int             – The width of the decay window.\n\nKeyword Arguments\n\nh=div(m,2)       :: Int               – The exponential decay half-life. \ninit_sig=nothing :: Union{Nothing, T} – An optional user supplied initial standard deviation for the start of the series.      \n\nInput Contract\n\nThe inputs are assumed to satisfy the constraints below.\n\nConstraint Description\nm > 1 Averaging window length is greater than 1.\nh > 1 Exponential half-life is greater than 1.\n|x| > 1 The length of the series is greater than 1.\ninit_sig ge 0 User supplied starting sigma should be ge 0.\n\nOutput\n\nstda :: AbstractVector{T} – The moving exponential standard deviation of x.\n\nOutput Contract\n\n|x| = |stda|\n\nReturn\n\nstda::Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"ema_stats","category":"page"},{"location":"#Finance.ema_stats","page":"Finance.jl Documentation","title":"Finance.ema_stats","text":"ema_stats(x, m; h=div(m,2), init_sig=nothing)\n\nCompute the Moving Exponential Stats of the sequence x: ema, ema_std, ema_rel_skew, ema_rel_kurtosis.\n\nThe recursive formulas for the moving statistics as well as the adjustments necessary to  render the estimates unbiased come from the paper: exponential_moving_average.pdf.\n\nReturns these stats as a matrix with four columns, each representing the stats above in the order listed.\n\nType Constraints\n\nT <: Real\n\nArguments\n\nx :: AbstractVector{T} – The series to work with.\nm :: Int             – The width of the decay window.\n\nKeyword Arguments\n\nh=div(m,2) :: Int     – The exponential decay half-life. \ninit_sig=nothing:: Union{T, Nothing} – An optional user supplied initial standard deviation for the start of the series.      \n\nInput Contract\n\nThe inputs are assumed to satisfy the constraints below:\n\nConstraint Description\nm > 1 Averaging window length is greater than 1.\nh > 1 Exponential half-life is greater than 1.\n|x| > 3 The length of the series is greater than 3.\n\nOutput\n\nstat :: Matrix{T} – A matrix of EMA stats: ema, ema_std, ema_rel_skew, ema_rel_kurtosis.\n\nOutput Contract\n\n|stat| = (N, 4) \n\nReturn\n\nstat::Matrix{T}\n\n\n\n\n\n","category":"function"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"std","category":"page"},{"location":"#Finance.std","page":"Finance.jl Documentation","title":"Finance.std","text":"std(x)\n\nCompute the \"sample\" standard deviation of a series, x.\n\nType Constraints\n\nT <: Real\n\nArguments\n\nx :: AbstractVector{T} – The series to work with.\n\nInput Contract\n\nThe inputs are assumed to satisfy the constraints below.\n\nConstraint Description\n|x| > 1 The length of the series is greater than 1.\n\nReturn\n\nstd::T – The sample standard deviation.\n\n\n\n\n\n","category":"function"},{"location":"#Utilities","page":"Finance.jl Documentation","title":"Utilities","text":"","category":"section"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"isConvertible","category":"page"},{"location":"#Finance.isConvertible","page":"Finance.jl Documentation","title":"Finance.isConvertible","text":"isConvertible(S, T)\n\nBoolean function which returns true if a value of type S  can be converted to a value of type T.\n\nType Constraints\n\nS <: Real\nT <: Real\n\nArguments\n\n::Type{S} – A numeric type.\n::Type{T} – A numeric type.\n\nReturn\n\n::Bool\n\n\n\n\n\n","category":"function"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"tic_diff1(::AbstractVector{T}, ::AbstractVector{S}; ::Bool=false) where {T <: Real, S <: Real}","category":"page"},{"location":"#Finance.tic_diff1-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T<:Real, S<:Real}","page":"Finance.jl Documentation","title":"Finance.tic_diff1","text":"tic_diff1(t, x; chk_inp=false)\n\nCompute the numerical derivative of a function represented by x with respect to t when the values in t are possibly irregular.\n\nType Constraints\n\nS <: Real\nT <: Real\n\nArguments\n\nt :: AbstractVector{T}   – A vector of times.\nx :: AbstractVector{S}   – A vector of values.\n\nKeyword Arguments\n\nchk_inp=false :: Bool  – Check the input contract?\n\nInput Contract\n\nThe inputs are assumed to satisfy the constraints below.\n\nConstraint Description\n|t| = |x| The length of the time and data vectors match.\nT => S Type T can be converted to type S.\nforall i t_i+1  t_i The times are increasing; consequently, we have a 1-1 map from t to x.\n\nReturn\n\n:: AbstractVector{S}\n\n\n\n\n\n","category":"method"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"tic_diff2(::AbstractVector{T}, ::AbstractVector{S}; ::Bool=false) where {T <: Real, S <: Real}","category":"page"},{"location":"#Finance.tic_diff2-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T<:Real, S<:Real}","page":"Finance.jl Documentation","title":"Finance.tic_diff2","text":"tic_diff2(t, x; chk_inp=false)\n\nCompute the numerical second derivative of a function represented by x with respect to t when the values in t are possibly irregular.\n\nType Constraints\n\nT <: Real\nS <: Real\n\nArguments\n\nt :: AbstractVector{T} – A vector of times.\nx :: AbstractVector{S} – A vector of values.\n\nKeyword Arguments\n\nchk_inp=false :: Bool  – Check the input contract?\n\nInput Contract\n\nThe inputs are assumed to satisfy the constraints below.\n\nConstraint Description\n|t| = |x| The length of the time and data vectors match.\nT => S Type T can be converted to type S.\nforall i t_i+1  t_i The times are increasing; consequently, we have a 1-1 map from t to x.\n\nReturn\n\n:: AbstractVector{S}\n\n\n\n\n\n","category":"method"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"pow_n(::T, ::Int) where {T <: Number} ","category":"page"},{"location":"#Finance.pow_n-Union{Tuple{T}, Tuple{T, Int64}} where T<:Number","page":"Finance.jl Documentation","title":"Finance.pow_n","text":"pow_n(x, n)\n\nFast (non-negative) integer powers: x^n. Uses repeated squaring in combination with the bit vector representation of n.\n\nType Constraints\n\nT <: Number\n\nArguments\n\nx::T     – The base value.\nn::Int – The power.\n\nInput Contract\n\nn ge 0 \n\nReturn\n\n::T        – The Power Value.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"pow_n(::T, ::Int, ::S) where {T <: Real, S <: Real} ","category":"page"},{"location":"#Finance.pow_n-Union{Tuple{S}, Tuple{T}, Tuple{T, Int64, S}} where {T<:Real, S<:Real}","page":"Finance.jl Documentation","title":"Finance.pow_n","text":"pow_n(x, n, m)\n\nFast integer (non-negative) powers with modulus: x^n  rm mod   m. Uses repeated squaring in combination with the bit vector representation of n.\n\nThe output will be of type T^* = typeof(promote(x, m)).\n\nType Constraints\n\nT <: Real\nS <: Real\n\nArguments\n\nx::T     – The base value.\nn::Int – The power.\nm::S     – The modulus.\n\nInput Contract\n\nn ge 0 \n\nReturn\n\nT^*    – The Power Value mod m.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"entropy_index(::AbstractVector{T}; ::Int=10, ::F=1.0 / (100 * n), ::Vector{F}=[0.01, 0.99], ::F=1.0) where {T <: Real, F <: AbstractFloat}","category":"page"},{"location":"#Finance.entropy_index-Union{Tuple{AbstractVector{T}}, Tuple{F}, Tuple{T}} where {T<:Real, F<:AbstractFloat}","page":"Finance.jl Documentation","title":"Finance.entropy_index","text":"entropy_index(x; <keyword arguments>)\n\nComputes a (Discounted) Binned Entropy Index. This is the ratio of entropy of the binned distribution of x against the entropy of the uniform distribution. The vector x is first capped by the lower and upper quantiles; then binned into n number of equal width bins. A distribution is formed  from the bins and the entropy computed. If λ is not 1, then a discounted entropy is computed. This is an exponentially based discounting of the  bin distribution based on their \"freshness\". In either event, the ratio of this entropy to  the entropy of the corresponding uniform distribution (of n bins) is returned.\n\nType Constraints\n\nT <: Real\nF <: AbstractFloat\n\nArguments\n\nx::AbstractVector{T}          – Vector to process.\n\nKeyword Arguments\n\nn=10::Int                     – Exponential.\ntol=1.0/(100 * n)::F          – Error tolerance used with equivalency test of number to 0 or 1.\nprobs=[0.01, 0.99]::Vector{F} – Vector of quantile min and max.\nλ=1.0::F                      – Discount value.\n\nInput Contract\n\nn > 2\n0 < tol < 0.01 \n|probs| == 2\n0  lambda le 1\n\nReturn\n\n::F – The (discounted) binned entropy index.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"ewt_mean(::Vector{AbstractFloat}, ::Vector{AbstractFloat}, ::Int, ::AbstractFloat)","category":"page"},{"location":"#Finance.ewt_mean-Tuple{Vector{AbstractFloat}, Vector{AbstractFloat}, Int64, AbstractFloat}","page":"Finance.jl Documentation","title":"Finance.ewt_mean","text":"ewt_mean(ts, xs, b, lm)\n\nComputes the moving (exponential decayed) temporal average of the data xs over windows of length b. Temporal averaging over a window means that the time stamps are differenced and we associate the difference of time points t_i t_i+1, Delta_i = t_i+1 - t_i, with the data point x_i. The rationale: The data point x_i has been around since t_i until t_i+1, so it should be should  weight it (in an un-normalized way) by this distance. The temporal decay will adjust the temporal weights by an exponential which puts more weight on recent data within the window. This is also done in an un-normalized way. Then the weights are normalized and data, xs, is averaged within the window.\n\nNOTE: Set lm to 1.0 to just have temporal weighting without decay.\n\nParameters\n\nts::Vector{AbstractFloat} – Data time stamps – ordered from smallest (oldest) to largest (newest).\nxs::Vectpr{AbstractFloat} – Data values associated with time stamps.\nb::Int            – The width of the window\nlm::AbstractFloat         – The decay factor: 0.0 < lm <= 1.0\n\nInput Contract\n\n|ts| == |xs|\n0 < b < |xs|\n0.0 < lm <= 1.0\n\nReturn\n\n::Vector{AbstractFloat} – A vector of length |xs| - b.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Finance.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"Finance.jl Documentation","title":"Finance.jl Documentation","text":"","category":"page"}]
}
